1. 객체지향 프로그래밍

클래스
가은 종류의 집단에 속하는 속성(변수)와 행위(메소드)를 정의한 것으로, 객체지향 프로그램의 기본적인
사용자 정의 데이터형(user define data type)이라고 할 수 있다.

예: 클래스(Class)- LectureRoom
-id: String
-name: String
-capa: int
-intRunning: boolean
-floor: int
행위(behavior)

-setId(id: String)
-getId() : String
-setName(name: String)
-getName(): String
-setCapa(capa: int)
-getCapa(): int
-setInsRunning(insRunning: boolean)
-getInsRunning(): boolean
-setFloor(floor: int)
-getFloor(): int


1.1.2 객체
클래스의 인스턴스(실제로 메모리상에 할당된 것)이다. 즉 클래스라는 일종의 설계도를 기반으로 실제로 
생성된 그 실체가 바로 객체이다. 객체는 자신의 고유한 속성(attribute)를 가지며, 클래스에서 정의한
행위(behavior)를 수행할 수 있다.

1.1.3 메시지(Message)와 메소드(Method)
클래스로부터 생성된 객체를 사용하는 방법으로써, 객체에 명령을 내리는 행위라고 할 수 있다.
메서드는 한 객체의 서브루틴 형태로 객체의 속성을 조작하는데 사용된다. 메시지는 객체간의 통신이 이루어지는
방법이며 이 메시지를 통해 메소드가 호출되어 사용된다. 메서드(Method) = 행위(behavior/operation) =
함수(function)

1.1.4 캡슐화(Encapsulation)
객체의 상세한 내용을 객체 외부에 철저히 숨기고 단순히 메시지만으로 객체와의 상호작용을 하게 하는 것.
정보은닉이라고도 하며 추상화랑 비슷한 표현이다. 예를들면, 클래스를 선언하고 그 클래스를 구성하는 객체에
대하여 "public" 또는 "private" 등으로 정의해준다. "public"으로 정의된 함수는 외부에서 사용이 가능
하지만, "private"으로 선언된 함수는 외부에서 제어가 불가능하다.

1.1.5 상속(Inheritance)
상속은 클래스의 속성과 행위를 하위 클래스에 물려주거나, 상위클래스로부터 물려받는 것을 지칭한다. 상속을 사용하면
재사용으로 인한 코드가 줄어들고, 하위 클래스에서 속성이나 행위를 다시 정의할 필요가 없기때문에 코드가 간결해진다.
좀 더 범용성있게 사용할 수 있다. 예를 들어, Object타입의 매개변수에는 String타입이나 int타입의 객체가 
쓰여도 문제되지 않는다. 왜냫면 String 과 int타입 모두 Object타입의 객체를 상속받은 하위클래스 이기때문이다.

-직접,간접상속
직접클래스: 파생 클래스 바로 위의 클래스
간접클래스: 직접 클래스 위의 클래스

-다중 한번에 둘 이상의 클래스를 파생받는 경우, 여러 부모를 둔경우 다중상속이라고 한다. 매우 직관적이지만 일반
클래스를 다중 상속하는 건 극히 꺼려지며 인터페이스 용도의 클래스에서만 상속받는게 일반적이다.

-죽음의 다이아몬드 The Deadly Diamong of Death, DDD
다중상소에서 상속받는 클래스에서 어느 부모의 메소드를 따라야 하는지가 명확하지 않아 문제가 생길 수 있음을 뜻하는
단어이다. 상속관계가 다이아몬드꼴으로 생겼다고해서 붙여진 이름이다.

1.1.6 다형성(Ploymorphism)
다양한 형태로 나타날 수 있는 특징을 뜻하며, 하나의 클래스 내부에 같은 이름의 행이를 여럿 정의하거나, 상위 클래스
의 오퍼레이션을 하위 클래스에서 다시 정의하여 사용할 수 있다.

# 메소드 오버로딩
클래스 내부에 동일한 이름의 행위를 여럿 정의하는 것.
함수명은 동일해야하고, 파라미터(매개변수)의 타입과 개수는 서로 달라야한다.
리턴타입은 상관없다.
메소드의 이름 낭비를 방지하고, 같은 메소드에 여러 종류의 매개변수를 받을 수 있다.

class student{

  void search(int number){
    system.out.println("번호" + number);
  }
  
  void search(string name){
    system.out.println("이름" + name);
  }
  
  void search(string name, int price){
    system.out.println("번호:"+number);
    system.out.println("이름:"+name);
  }
}

# 메소드 오버라이딩
상속으로 물려받은 자료나 메소드를 그대로 사용하지 않고, 자신이 새로 재정의해서 사용하는 것.
함수명은 같아야하고, 파라미터의 타입과 개수는 동일해야 한다. 
리턴타입도 같아야한다.
  

class Student{

  void show(){
    
    System.out.println("학생");
  }
}

class ScienceStudent extends student{
  
  void show(){

    System.out.println("과학동아리학생");
    
  }
} 

# 객체지향프로그래밍의 3요소
1. 상속, 2.캡슐화, 3.다형성

1.1.7. 객체지향과 절차지향의 비교
객체지향프로그래밍 : 프로그래밍을 함에 잇어서 데이터와 그 데이터를 처리할 메소드를 한데 묶어 객체를 만들고 블럭쌓듯이
객체를 조립하여 프로그래밍을 하는 언어. 객체지향의 특징으로는 추상화,캡슈로하,상속,다형성이 있다.
  
# 객체지향프로그래밍의 원칙
객체지향 프로그래밍 5원칙 (SOLID) 객체지향에서 지켜야할 5개의 원칙을 말한다.
 - SRP : 단일책임원칙, 객체는 오직 하나의 책임을 가져야만한다. 하나의 클래스가 두 가지 이상의 책임을 지니게 되면 
  클래스의 목적이 모호해지고 수정이 힘들어져 유지보수가 힘들어지고, 이해하기 어려운 코드가 된다.
 - OCP : 개방-폐쇄 원칙, 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다.
 - LSP : 리스코프 치환 법칙, 자식 클래스는 언제나 부모클래스를 대체할 수 있다. 상속의 본질
 - ISP : 인터페이스 분리 법칙, 클라이언트에서 사용하지 않는 메소드는 사용해서는 안된다. 
 - DIP : 의존성 역전 원칙, 추상성이 높고 아넞ㅇ적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는
 안된다. 일반적으로 객체지향의 인터페이스를 통해서 이원칙을 준수할 수 있게된다.

   
2. 객체지향 언어의    
1. 객체지향의 개념 및 소개
1.2.1. JAVA : 썬 마이크로 시스템즈에서 1995년 개발한 객체지향프로그래밍 언어, 창시자는 제임스 고슬링.
  Java SE(표준에디션),Jakarta EE(기업운영 서버페이지특화에디션), Java ME(PDA나 셋톱박스,센서등의 임베디드환경 특화)
  Java FX(데스킄톱 에플리케이션 특화)
  
# 특징
플랫폼에 독립적인 언어로 운영체제에 상관없이 JVM(Java Virtual Machine)만 설치되어있다면 문제 없이 작동한다.
  수많은 개발자와 레퍼런스가 존재하며, 높은 생산성
  C++에서 안정성 문제가 제기되는 포인터 연산자, 메모리 직접접근 함수, 다중 상속을 허용하지 않는다.
  높은 소스코드의 가독성, 축약어사용 자제, 가비지컬렉션 사용 등
  
1.2.2 C++ : 1983년 C언어에서 직접적으로 파생된 프로그래밍 언어. 비아네 스트로스트룹이 객체지향언어 Simula의 컨셉을
C언어에 접목시키면서 탄생. C에 OO개념을 추가하고 일반화 프로그래밍의 요소가 되는 STL을 붙였다.
  
# 특징
최대한 많은 것을 컴파일 타임에 처리하는 것을 지향하며 메모리 등을 프로그래머가 직접 관리하도록한다. 프로그램의 성능하락이 거의
없다. 프로그램 실행시간이 빠르지만, 컴파일 시간은 오래걸린다.
  
1.2.3. 그 밖의 언어들
- Smalltalk : 1972년 엘런케이. 최초로 OOP를 지원한 프로그램.
- Ruby : 순수 객체지향 언어로, 마츠모토 유키히로에 의해 만들어짐. 쉬운 난이도.
- Python : 귀도 판 로썸. 
- Objective - C : 1983년 브래드 콕스와 톰 러브. C언어의 파생형.
  
  
   
